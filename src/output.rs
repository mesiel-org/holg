use std::collections::HashSet;
use std::fs::File;
use std::io::{self, Write};
use std::path::PathBuf;

/// Write metadata block to the output file
/// Returns `io::Error` if writing fails
fn write_metadata_block(
  out: &mut File,
  headers: &Vec<(PathBuf, String)>,
  impls: &Vec<(PathBuf, String)>,
  sys_includes: &HashSet<String>,
) -> io::Result<()> {
  let current_time = chrono::Local::now();

  writeln!(
    out,
    "// ========================================================="
  )?;
  writeln!(
    out,
    "// THIS FILE IS GENERATED BY HOLG AT {}",
    current_time.format("%Y-%m-%d %H:%M:%S")
  )?;
  writeln!(
    out,
    "// PART OF MESIEL PROJECT (https://github.com/mesiel-org)"
  )?;
  writeln!(out, "// VERSION {}", env!("CARGO_PKG_VERSION"))?;
  writeln!(
    out,
    "// ---------------------------------------------------------"
  )?;
  writeln!(out, "// SUMMARY")?;
  writeln!(out, "//   Total headers processed: {}", headers.len())?;
  writeln!(
    out,
    "//   Total source files processed: {}",
    impls.len()
  )?;
  writeln!(out, "//   System includes: {}", sys_includes.len())?;
  writeln!(
    out,
    "// ---------------------------------------------------------"
  )?;
  writeln!(out, "// FILES PROCESSED")?;
  for file in headers.iter().chain(impls.iter()) {
    writeln!(out, "//   {}", file.0.display())?;
  }
  writeln!(
    out,
    "// =========================================================\n"
  )?;
  Ok(())
}

/// write ASCII box comment with a title
pub fn write_ascii_box_comment(out: &mut File, title: &str) -> io::Result<()> {
  writeln!(out, "")?;
  let border = format!("+{}+", "-".repeat(title.len() + 2));
  writeln!(out, "// {}", border)?;
  writeln!(out, "// | {} |", title)?;
  writeln!(out, "// {}", border)?;
  writeln!(out, "")?;
  Ok(())
}

/// check if file looks like C++ source/header
fn is_cpp_file(path: &PathBuf) -> bool {
  if let Some(ext) = path.extension().and_then(|e| e.to_str()) {
    matches!(ext, "cpp" | "cxx" | "cc" | "C" | "hpp" | "hh" | "hxx")
  } else {
    false
  }
}

/// Write output file
/// Returns `io::Error` if writing fails
pub fn write_output(
  out_path: &PathBuf,
  impl_macro: &str,
  headers: Vec<(PathBuf, String)>,
  impls: Vec<(PathBuf, String)>,
  sys_includes: HashSet<String>,
) -> io::Result<()> {
  let mut out = File::create(out_path)?;

  // metadata + includes
  write_metadata_block(&mut out, &headers, &impls, &sys_includes)?;
  writeln!(out, "#pragma once")?;

  let mut sorted_includes: Vec<_> = sys_includes.into_iter().collect();
  sorted_includes.sort();
  for inc in sorted_includes {
    writeln!(out, "{}", inc)?;
  }

  // ---- HEADERS ----
  for (path, content) in &headers {
    write_ascii_box_comment(&mut out, &format!("HEADER: {}", path.display()))?;

    let needs_extern = !is_cpp_file(path);
    if needs_extern {
      writeln!(out, "#ifdef __cplusplus")?;
      writeln!(out, "extern \"C\" {{")?;
      writeln!(out, "#endif")?;
    }

    for line in content.lines() {
      writeln!(out, "{}", line)?;
    }

    if needs_extern {
      writeln!(out, "#ifdef __cplusplus")?;
      writeln!(out, "}} // extern \"C\"")?;
      writeln!(out, "#endif")?;
    }
  }

  // ---- IMPLEMENTATION ----
  writeln!(out, "#ifndef {}_IMPLEMENTATION", impl_macro)?;
  writeln!(out, "#define {}_IMPLEMENTATION", impl_macro)?;

  for (path, content) in impls {
    write_ascii_box_comment(&mut out, &format!("IMPL: {}", path.display()))?;

    let needs_extern = !is_cpp_file(&path);
    if needs_extern {
      writeln!(out, "#ifdef __cplusplus")?;
      writeln!(out, "extern \"C\" {{")?;
      writeln!(out, "#endif")?;
    }

    for line in content.lines() {
      writeln!(out, "{}", line)?;
    }

    if needs_extern {
      writeln!(out, "#ifdef __cplusplus")?;
      writeln!(out, "}} // extern \"C\"")?;
      writeln!(out, "#endif")?;
    }
  }

  writeln!(out, "#endif // {}_IMPLEMENTATION", impl_macro)?;
  Ok(())
}
